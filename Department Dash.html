
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DD - BMB Department Dash</title>
  <style>
    :root { color-scheme: light; }
    body{
      margin:0; min-height:100vh; display:grid; place-items:center;
      background: linear-gradient(180deg, #f7f1d8 0%, #efe2b5 40%, #2b2f3a 100%);
      color:#1c2330;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .wrap{ width:min(1100px, 96vw); }
    header{
      display:flex; justify-content:space-between; align-items:baseline;
      margin:10px 0 8px; gap:12px; flex-wrap:wrap;
    }
    h1{ margin:0; font-size:16px; letter-spacing:.4px; opacity:.95; }
    .hud{ display:flex; gap:14px; flex-wrap:wrap; font-size:14px; opacity:.92; justify-content:flex-end; }
    canvas{
      width:100%; height:auto; display:block;
      border-radius:16px;
      border:1px solid rgba(0,0,0,.10);
      background: linear-gradient(180deg, #fbf4d8 0%, #f3e7bf 55%, #d8c98f 100%);
      box-shadow: 0 16px 46px rgba(0,0,0,.25);
      user-select:none; touch-action:manipulation;
    }
    .panel{
      margin-top:10px;
      border:1px solid rgba(0,0,0,.10);
      border-radius:16px;
      background: rgba(255,255,255,.55);
      padding:12px 14px;
      display:flex; flex-wrap:wrap; gap:10px; align-items:flex-start; justify-content:space-between;
      backdrop-filter: blur(6px);
    }
    .pills{ display:flex; flex-wrap:wrap; gap:8px; }
    .pill{
      border:1px solid rgba(0,0,0,.12);
      background: rgba(255,255,255,.65);
      padding:6px 10px; border-radius:999px;
      font-size:13px; opacity:.95;
    }
    button{
      cursor:pointer;
      border:1px solid rgba(0,0,0,.18);
      background: rgba(255,255,255,.75);
      color:#132033;
      padding:8px 12px; border-radius:12px;
      font-size:14px;
    }
    button:hover{ background: rgba(255,255,255,.90); }
    .smallnote{
      font-size:12px;
      opacity:.78;
      line-height:1.35;
      margin-top:6px;
    }
    code{ background: rgba(0,0,0,.06); padding:2px 6px; border-radius:8px; }
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>DD - BMB Department Dash</h1>
      <div class="hud">
        <div>Score: <b id="score">0</b></div>
        <div>Best: <b id="best">0</b></div>
        <div>Speed: <b id="spd">1.0x</b></div>
        <div>Difficulty: <b id="dif">1.0x</b></div>
        <div>Music: <b id="msc">On</b></div>
        <div>SFX: <b id="snd">On</b></div>
      </div>
    </header>

    <canvas id="game" width="960" height="540"></canvas>

    <div class="panel">
      <div style="display:grid; gap:10px;">
        <div class="pills">
          <div class="pill"><b>Space</b>/<b>W</b>/<b>↑</b> Jump</div>
          <div class="pill"><b>F</b> Throw Pen</div>
          <div class="pill"><b>Enter</b> Start/Pause</div>
          <div class="pill"><b>R</b> Restart</div>
          <div class="pill">Click/Tap = Throw Pen</div>
        </div>

        <div style="display:flex; gap:10px; flex-wrap:wrap;">
          <button id="btnStart">Start / Continue</button>
          <button id="btnPause">Pause</button>
          <button id="btnRestart">Restart</button>
          <button id="btnMusic">Toggle Music</button>
          <button id="btnSfx">Toggle SFX</button>
        </div>

        <div class="smallnote">
          <b>Music:</b> put <code>bg_music.mp3</code> and <code>gameover.mp3</code> in the same folder as <code>index.html</code>.
        </div>
        <div class="smallnote">
          <b>Permanent teacher photos:</b> put them in <code>assets/</code> as:
          <code>zhh.png</code>, <code>meh.png</code>, <code>nn.png</code>.
        </div>
      </div>

      <div style="max-width:520px">
        <div class="smallnote">
          If images don’t load, check spelling + file extensions. Folder must be exactly <b>assets</b>.
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");

  const scoreEl = document.getElementById("score");
  const bestEl  = document.getElementById("best");
  const spdEl   = document.getElementById("spd");
  const difEl   = document.getElementById("dif");
  const mscEl   = document.getElementById("msc");
  const sndEl   = document.getElementById("snd");

  const btnStart   = document.getElementById("btnStart");
  const btnPause   = document.getElementById("btnPause");
  const btnRestart = document.getElementById("btnRestart");
  const btnMusic   = document.getElementById("btnMusic");
  const btnSfx     = document.getElementById("btnSfx");

  const W = canvas.width;
  const H = canvas.height;

  // World
  const groundY = 430;
  const gravity = 2350;
  const jumpVel = 900;

  // Speed (NO CAP): increases until game ends
  const baseSpeed = 190; // 1.0x baseline

  // Difficulty curve (controls BOTH speed + spawn frequency growth)
  // Make it grow steadily but not instantly insane:
  // - after 60s: ~1.9x difficulty
  // - after 120s: ~2.8x difficulty
  // - continues upward
  function difficultyFromTime(t){
    return 1 + (t / 55); // linear ramp; tweak 55 to change pace
  }

  const loseScore = -50;

  // Base spawn ranges (will be divided by difficulty => more frequent later)
  const teacherSpawnMin = 2.2;
  const teacherSpawnMax = 3.8;
  const examSpawnMin    = 4.6;   // rarer
  const examSpawnMax    = 7.4;

  // How much spawn speeds up relative to difficulty
  const teacherSpawnScale = 1.0; // full effect
  const examSpawnScale    = 0.65; // slower effect so exams stay rarer

  // Pen
  const penSpeed = 880;
  const penCooldownMs = 180;

  // State
  let mode = "WELCOME";
  let running = false;
  let gameOver = false;

  let score = 0;
  let best = Number(localStorage.getItem("dd_bmb_best") || "0");
  bestEl.textContent = best;

  let aliveTime = 0;
  let speed = baseSpeed;

  // Toggles
  let sfxOn = true;
  let musicOn = true;
  sndEl.textContent = sfxOn ? "On" : "Off";
  mscEl.textContent = musicOn ? "On" : "Off";

  // Music files
  const BG_MUSIC_FILE = "bg_music.mp3";
  const GAMEOVER_MUSIC_FILE = "gameover.mp3";

  const audio = {
    bg: new Audio(BG_MUSIC_FILE),
    go: new Audio(GAMEOVER_MUSIC_FILE),
    init() {
      this.bg.loop = true;
      this.bg.volume = 0.35;
      this.go.loop = false;
      this.go.volume = 0.85;
    },
    startBG() {
      if (!musicOn) return;
      this.go.pause();
      this.go.currentTime = 0;
      this.bg.play().catch(()=>{});
    },
    stopBG() { this.bg.pause(); },
    playGameOver() {
      if (!musicOn) return;
      this.bg.pause();
      this.bg.currentTime = 0;
      this.go.currentTime = 0;
      this.go.play().catch(()=>{});
    },
    ding() {
      if (!sfxOn) return;
      const A = window.AudioContext || window.webkitAudioContext;
      audio._ctx = audio._ctx || new A();
      const ac = audio._ctx;
      if (ac.state === "suspended") ac.resume();

      const o = ac.createOscillator();
      const g = ac.createGain();
      o.type = "sine";
      o.frequency.value = 988;
      const now = ac.currentTime;
      g.gain.setValueAtTime(0.0001, now);
      g.gain.exponentialRampToValueAtTime(0.28, now + 0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, now + 0.16);
      o.connect(g); g.connect(ac.destination);
      o.start(now);
      o.stop(now + 0.18);
    }
  };
  audio.init();

  function ensureMusicState(){
    if (!musicOn) { audio.stopBG(); audio.go.pause(); return; }
    if (mode === "PLAY" && running && !gameOver) audio.startBG();
    else audio.stopBG();
  }

  // Helpers
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const rand  = (a,b)=>a+Math.random()*(b-a);
  function overlap(a,b){
    return a.x < b.x + b.w && a.x + a.w > b.x &&
           a.y < b.y + b.h && a.y + a.h > b.y;
  }

  // Player
  const player = { x: 110, y: groundY - 92, w: 44, h: 92, vy: 0, onGround: true, invuln: 0 };

  const teachers = [];
  const exams = [];
  const pens  = [];

  let nextTeacher = rand(teacherSpawnMin, teacherSpawnMax);
  let nextExam    = rand(examSpawnMin, examSpawnMax);

  let wantJump = false;
  let wantShoot = false;

  const teacherKeys = ["ZHH", "MEH", "NN"];

  // ========= Permanent teacher images (from files) =========
  // Put these files in: assets/zhh.png assets/meh.png assets/nn.png
  const teacherPhoto = { ZHH: null, MEH: null, NN: null };

  function loadImg(path){
    return new Promise((resolve) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = () => resolve(null); // if missing, just return null
      img.src = path;
    });
  }

  async function loadTeacherPhotos(){
    teacherPhoto.ZHH = await loadImg("assets/zhh.png");
    teacherPhoto.MEH = await loadImg("assets/meh.png");
    teacherPhoto.NN  = await loadImg("assets/nn.png");
  }

  // Fallback cartoon faces if image files are missing
  function svgToImg(svg) {
    const img = new Image();
    const encoded = encodeURIComponent(svg).replace(/'/g, "%27").replace(/"/g, "%22");
    img.src = `data:image/svg+xml;charset=utf-8,${encoded}`;
    return img;
  }
  const builtFace = {
    ZHH: svgToImg(`<svg xmlns="http://www.w3.org/2000/svg" width="220" height="220"><rect width="220" height="220" rx="28" fill="#ffb6d5"/><circle cx="110" cy="104" r="62" fill="#ffe6c7"/><circle cx="90" cy="98" r="7" fill="#111"/><circle cx="130" cy="98" r="7" fill="#111"/><path d="M90 132 Q110 148 130 132" stroke="#c96a6a" stroke-width="7" fill="none" stroke-linecap="round"/><text x="110" y="205" font-size="32" text-anchor="middle" fill="#112" opacity=".75" font-family="Arial">ZHH</text></svg>`),
    MEH: svgToImg(`<svg xmlns="http://www.w3.org/2000/svg" width="220" height="220"><rect width="220" height="220" rx="28" fill="#7bf1c6"/><circle cx="110" cy="104" r="62" fill="#ffe6c7"/><rect x="70" y="86" width="80" height="20" rx="10" fill="#000" opacity=".18"/><circle cx="92" cy="98" r="7" fill="#111"/><circle cx="128" cy="98" r="7" fill="#111"/><path d="M90 132 Q110 124 130 132" stroke="#b55" stroke-width="7" fill="none" stroke-linecap="round"/><text x="110" y="205" font-size="32" text-anchor="middle" fill="#112" opacity=".75" font-family="Arial">MEH</text></svg>`),
    NN:  svgToImg(`<svg xmlns="http://www.w3.org/2000/svg" width="220" height="220"><rect width="220" height="220" rx="28" fill="#93a9ff"/><circle cx="110" cy="104" r="62" fill="#ffe6c7"/><path d="M70 78 Q110 52 150 78" stroke="#2b2b2b" stroke-width="18" stroke-linecap="round" opacity=".25"/><circle cx="92" cy="98" r="7" fill="#111"/><circle cx="128" cy="98" r="7" fill="#111"/><path d="M90 132 Q110 148 130 132" stroke="#c96a6a" stroke-width="7" fill="none" stroke-linecap="round"/><text x="110" y="205" font-size="32" text-anchor="middle" fill="#112" opacity=".75" font-family="Arial">NN</text></svg>`)
  };

  function getTeacherFace(key){
    // prefer real photos if available
    return teacherPhoto[key] || builtFace[key];
  }

  // Background doors
  const doorLabels = ["KAL Gallery", "Photosynthesis Lab", "NHL", "PopGen"];
  const doors = [];
  function initDoors(){
    doors.length = 0;
    for (let i=0;i<6;i++){
      doors.push({ x: i*320 + 180, y: 115, w: 120, h: 225, label: doorLabels[Math.floor(rand(0, doorLabels.length))] });
    }
  }
  initDoors();

  // Controls
  function jump(){
    if (!running || gameOver || mode !== "PLAY") return;
    if (player.onGround){
      player.vy = -jumpVel;
      player.onGround = false;
    }
  }
  function shoot(){
    if (!running || gameOver || mode !== "PLAY") return;
    const now = performance.now();
    if (shoot.last && now - shoot.last < penCooldownMs) return;
    shoot.last = now;
    pens.push({ x: player.x + player.w + 18, y: player.y + 44, w: 64, h: 10, vx: penSpeed });
  }

  // Input
  window.addEventListener("keydown", (e)=>{
    if (["Space","ArrowUp","KeyW"].includes(e.code)){ e.preventDefault(); wantJump = true; }
    if (e.code === "KeyF") wantShoot = true;
    if (e.code === "Enter") toggleStartPause();
    if (e.code === "KeyR") restart();
  });
  window.addEventListener("keyup", (e)=>{
    if (["Space","ArrowUp","KeyW"].includes(e.code)) wantJump = false;
    if (e.code === "KeyF") wantShoot = false;
  });

  canvas.addEventListener("pointerdown", (e)=>{
    if (mode === "WELCOME") { mode = "INSTRUCTIONS"; return; }
    if (mode === "INSTRUCTIONS") { mode = "PLAY"; running = true; ensureMusicState(); return; }
    if (gameOver) { restart(); return; }
    shoot();
    canvas.setPointerCapture?.(e.pointerId);
  });

  btnStart.onclick = ()=>{
    if (mode === "WELCOME") { mode = "INSTRUCTIONS"; return; }
    if (mode === "INSTRUCTIONS") { mode = "PLAY"; running = true; ensureMusicState(); return; }
    if (gameOver) restart();
    running = true;
    ensureMusicState();
  };
  btnPause.onclick = ()=>{ running = false; ensureMusicState(); };
  btnRestart.onclick = ()=>restart();

  btnMusic.onclick = ()=>{
    musicOn = !musicOn;
    mscEl.textContent = musicOn ? "On" : "Off";
    ensureMusicState();
  };
  btnSfx.onclick = ()=>{
    sfxOn = !sfxOn;
    sndEl.textContent = sfxOn ? "On" : "Off";
  };

  function toggleStartPause(){
    if (mode === "WELCOME") { mode = "INSTRUCTIONS"; return; }
    if (mode === "INSTRUCTIONS") { mode = "PLAY"; running = true; ensureMusicState(); return; }
    if (gameOver) return;
    running = !running;
    ensureMusicState();
  }

  // Spawning
  function spawnTeacher(){
    const h = 86, w = 52;
    teachers.push({ x: W + 40, y: groundY - h, w, h, who: teacherKeys[Math.floor(rand(0, teacherKeys.length))], dead:false, fade:1 });
  }
  function spawnExam(){
    const h = 46, w = 68;
    const type = Math.random() < 0.7 ? "MIDTERM" : "FINAL";
    exams.push({ x: W + 40, y: groundY - h, w, h, type });
  }

  function restart(){
    running = (mode === "PLAY");
    gameOver = false;
    score = 0;
    aliveTime = 0;
    speed = baseSpeed;

    player.y = groundY - player.h;
    player.vy = 0;
    player.onGround = true;
    player.invuln = 0;

    teachers.length = 0;
    exams.length = 0;
    pens.length  = 0;

    nextTeacher = rand(teacherSpawnMin, teacherSpawnMax);
    nextExam    = rand(examSpawnMin, examSpawnMax);

    initDoors();
    updateHUD();
    ensureMusicState();
  }

  function endGame(msg){
    running = false;
    gameOver = true;
    endGame.msg = msg || "Game Over";
    if (score > best){
      best = score;
      localStorage.setItem("dd_bmb_best", String(best));
      bestEl.textContent = best;
    }
    ensureMusicState();
    audio.playGameOver();
  }

  function update(dt){
    if (mode !== "PLAY") return;
    if (!running || gameOver) return;

    aliveTime += dt;

    // Difficulty grows with time
    const dif = difficultyFromTime(aliveTime);
    difEl.textContent = dif.toFixed(1) + "x";

    // Speed grows with difficulty (NO CAP)
    speed = baseSpeed * (0.95 + 0.75 * dif); // steady ramp; keeps increasing
    const mult = speed / baseSpeed;
    spdEl.textContent = mult.toFixed(1) + "x";

    if (wantJump) jump();
    if (wantShoot) shoot();

    // physics
    player.invuln = Math.max(0, player.invuln - dt);
    player.vy += gravity * dt;
    player.y += player.vy * dt;
    if (player.y >= groundY - player.h){
      player.y = groundY - player.h;
      player.vy = 0;
      player.onGround = true;
    }

    // spawn timers (frequency increases with difficulty)
    nextTeacher -= dt;
    nextExam    -= dt;

    const tScale = Math.max(1, dif * teacherSpawnScale);
    const eScale = Math.max(1, dif * examSpawnScale);

    if (nextTeacher <= 0){
      spawnTeacher();
      nextTeacher = rand(teacherSpawnMin, teacherSpawnMax) / tScale;
    }
    if (nextExam <= 0){
      spawnExam();
      nextExam = rand(examSpawnMin, examSpawnMax) / eScale;
    }

    // move doors
    for (const d of doors) d.x -= speed * dt * 0.22;
    wrapDoors();

    // pens
    for (const p of pens) p.x += p.vx * dt;
    for (let i=pens.length-1;i>=0;i--){
      if (pens[i].x > W + 200) pens.splice(i,1);
    }

    // obstacles
    for (const te of teachers) te.x -= speed * dt;
    for (const ex of exams) ex.x -= speed * dt;

    // pen hits teacher: +2
    for (const te of teachers){
      if (te.dead) continue;
      for (let i=pens.length-1;i>=0;i--){
        if (overlap(te, pens[i])){
          pens.splice(i,1);
          te.dead = true;
          score += 2;
          audio.ding();
          break;
        }
      }
    }

    // cleanup
    for (let i=teachers.length-1;i>=0;i--){
      const te = teachers[i];
      if (te.dead) te.fade -= dt * 2.3;
      if (te.x + te.w < -200 || te.fade <= 0) teachers.splice(i,1);
    }
    for (let i=exams.length-1;i>=0;i--){
      if (exams[i].x + exams[i].w < -200) exams.splice(i,1);
    }

    // teacher collision -> game over
    for (const te of teachers){
      if (te.dead) continue;
      if (overlap(player, te)){ endGame("Teacher caught you!"); return; }
    }

    // exam collision -> penalty
    if (player.invuln <= 0){
      for (const ex of exams){
        if (overlap(player, ex)){
          score -= (ex.type === "FINAL" ? 10 : 5);
          player.invuln = 0.6;
          break;
        }
      }
    }

    if (score <= loseScore){
      endGame("You reached -50 points!");
      return;
    }

    score += Math.floor(dt * 1);
    updateHUD();
  }

  function wrapDoors(){
    for (const d of doors){
      if (d.x + d.w < -120){
        const maxX = Math.max(...doors.map(o => o.x));
        d.x = maxX + 320;
        d.label = doorLabels[Math.floor(rand(0, doorLabels.length))];
      }
    }
  }

  function updateHUD(){ scoreEl.textContent = score; }

  // Drawing
  function draw(){
    ctx.clearRect(0,0,W,H);
    if (mode === "WELCOME") { drawWelcome(); return; }
    if (mode === "INSTRUCTIONS") { drawInstructions(); return; }

    drawWarmWalls();
    drawDoors();
    drawGround();
    drawCartoonHuman(player);

    for (const p of pens) drawRealPen(p);
    for (const te of teachers) drawTeacherWithBody(te);
    for (const ex of exams) drawExam(ex);

    if (!running && !gameOver) overlay("Paused", "Press Enter or click Start / Continue");
    if (gameOver) overlay("Game Over", (endGame.msg || "Try again") + "  (Press R)");
  }

  function drawWelcome(){
    ctx.save();
    ctx.fillStyle = "rgba(255,255,255,0.35)";
    ctx.fillRect(0,0,W,H);
    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(25,30,40,0.95)";
    ctx.font = "900 50px system-ui";
    ctx.fillText("DD - BMB Department Dash", W/2, 180);
    ctx.fillStyle = "rgba(25,30,40,0.78)";
    ctx.font = "20px system-ui";
    ctx.fillText("“Stay sterile. Think molecular. Survive the corridor.”", W/2, 232);
    ctx.fillStyle = "rgba(25,30,40,0.70)";
    ctx.font = "16px system-ui";
    ctx.fillText("Click / Tap / Press Enter to continue", W/2, 290);
    ctx.restore();
  }

  function drawInstructions(){
    ctx.save();
    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(25,30,40,0.94)";
    ctx.font = "900 44px system-ui";
    ctx.fillText("How to Play (BMB Edition)", W/2, 110);

    ctx.font = "18px system-ui";
    ctx.fillStyle = "rgba(25,30,40,0.82)";
    const lines = [
      "Teachers (ZHH / MEH / NN): touch them → GAME OVER.",
      "Throw a pen to destroy teachers: hit → +2 points (ding).",
      "Exams: cannot be destroyed — only jump over them.",
      "Hit MIDTERM → -5 points. Hit FINAL → -10 points.",
      "If your score reaches -50 → you lose.",
      "Speed + obstacle frequency increase as you survive."
    ];
    let y = 170;
    for (const line of lines) { ctx.fillText(line, W/2, y); y += 32; }

    ctx.fillStyle = "rgba(25,30,40,0.70)";
    ctx.font = "16px system-ui";
    ctx.fillText("Click / Tap / Press Enter to start playing", W/2, 420);
    ctx.restore();
  }

  function drawWarmWalls(){
    const wall = ctx.createLinearGradient(0,0,0,groundY);
    wall.addColorStop(0, "rgba(255,252,238,1)");
    wall.addColorStop(0.55, "rgba(247,238,205,1)");
    wall.addColorStop(1, "rgba(238,225,180,1)");
    ctx.fillStyle = wall;
    ctx.fillRect(0,0,W,groundY);

    ctx.globalAlpha = 0.06;
    ctx.fillStyle = "rgba(80,70,40,1)";
    for (let i = 0; i < 170; i++){
      const x = (i*57) % W;
      const y = (i*31) % (groundY-24);
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;

    ctx.globalAlpha = 0.20;
    ctx.fillStyle = "rgba(60,55,40,1)";
    ctx.fillRect(0, 66, W, 4);
    ctx.globalAlpha = 1;
  }

  function drawDoors(){
    for (const d of doors){
      ctx.globalAlpha = 0.14;
      ctx.fillStyle = "rgba(40,35,20,1)";
      roundRect(d.x-6, d.y-6, d.w+12, d.h+12, 14);
      ctx.fill();

      ctx.globalAlpha = 0.20;
      ctx.fillStyle = "rgba(255,255,255,1)";
      roundRect(d.x, d.y, d.w, d.h, 12);
      ctx.fill();

      ctx.globalAlpha = 0.22;
      ctx.fillStyle = "rgba(20,20,20,1)";
      roundRect(d.x+10, d.y+14, d.w-20, 20, 10);
      ctx.fill();

      ctx.globalAlpha = 0.80;
      ctx.fillStyle = "rgba(255,255,255,0.95)";
      ctx.font = "bold 13px system-ui";
      ctx.fillText(d.label, d.x+16, d.y+29);
    }
    ctx.globalAlpha = 1;
  }

  function drawGround(){
    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(60,55,40,0.35)";
    ctx.fillRect(0, groundY, W, 3);

    const floor = ctx.createLinearGradient(0,groundY,0,H);
    floor.addColorStop(0, "rgba(210,195,150,1)");
    floor.addColorStop(1, "rgba(160,140,95,1)");
    ctx.globalAlpha = 1;
    ctx.fillStyle = floor;
    ctx.fillRect(0, groundY+3, W, H-groundY-3);
  }

  function drawCartoonHuman(p){
    ctx.save();
    const x = p.x, y = p.y;

    ctx.globalAlpha = 0.12;
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.ellipse(x + 22, groundY + 10, 18, 8, 0, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(40,60,110,0.95)";
    roundRect(x+12, y+60, 10, 28, 6); ctx.fill();
    roundRect(x+24, y+60, 10, 28, 6); ctx.fill();

    ctx.fillStyle = "rgba(20,20,30,0.9)";
    roundRect(x+10, y+84, 14, 8, 4); ctx.fill();
    roundRect(x+22, y+84, 14, 8, 4); ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.95)";
    roundRect(x+8, y+32, 28, 34, 10); ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    roundRect(x+2, y+36, 10, 26, 8); ctx.fill();
    roundRect(x+34, y+36, 10, 26, 8); ctx.fill();

    ctx.fillStyle = "rgba(255,230,200,0.97)";
    ctx.beginPath();
    ctx.arc(x+22, y+18, 14, 0, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.25;
    ctx.fillStyle = "rgba(10,10,20,1)";
    ctx.beginPath();
    ctx.arc(x+22, y+14, 14, Math.PI, Math.PI*2);
    ctx.fill();

    ctx.globalAlpha = 0.85;
    ctx.fillStyle = "rgba(20,20,25,1)";
    ctx.beginPath(); ctx.arc(x+16, y+18, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+28, y+18, 2.2, 0, Math.PI*2); ctx.fill();
    ctx.globalAlpha = 1;

    if (p.invuln > 0){
      ctx.globalAlpha = 0.12;
      ctx.fillStyle = "white";
      roundRect(x-10, y-10, 64, 112, 16);
      ctx.fill();
    }
    ctx.restore();
  }

  function drawRealPen(p){
    ctx.save();
    ctx.translate(p.x, p.y);

    const barrel = ctx.createLinearGradient(0,0,p.w,0);
    barrel.addColorStop(0, "rgba(235,245,255,0.9)");
    barrel.addColorStop(0.45, "rgba(140,190,255,0.75)");
    barrel.addColorStop(1, "rgba(90,130,235,0.78)");
    ctx.fillStyle = barrel;
    ctx.globalAlpha = 0.95;
    roundRect(0, 0, p.w-12, p.h, 5); ctx.fill();

    const grip = ctx.createLinearGradient(0,0,0,p.h);
    grip.addColorStop(0, "rgba(30,30,50,0.7)");
    grip.addColorStop(1, "rgba(10,10,20,0.8)");
    ctx.fillStyle = grip;
    roundRect(10, 1, 18, p.h-2, 5); ctx.fill();

    const tip = ctx.createLinearGradient(p.w-16,0,p.w,0);
    tip.addColorStop(0, "rgba(240,240,245,0.9)");
    tip.addColorStop(1, "rgba(120,120,130,0.9)");
    ctx.fillStyle = tip;
    ctx.beginPath();
    ctx.moveTo(p.w-12, 0); ctx.lineTo(p.w, p.h/2); ctx.lineTo(p.w-12, p.h);
    ctx.closePath(); ctx.fill();

    ctx.restore();
    ctx.globalAlpha = 1;
  }

  // Teacher with body + photo face + very visible name badge
  function drawTeacherWithBody(te){
    ctx.save();
    const alpha = te.dead ? Math.max(0, te.fade) * 0.35 : 0.98;
    ctx.globalAlpha = alpha;

    const x = te.x, y = te.y;

    // lab coat body
    ctx.fillStyle = "rgba(255,255,255,0.93)";
    roundRect(x, y+30, te.w, te.h-30, 12); ctx.fill();

    ctx.fillStyle = "rgba(45,60,110,0.9)";
    roundRect(x+10, y+te.h-26, 10, 24, 6); ctx.fill();
    roundRect(x+te.w-20, y+te.h-26, 10, 24, 6); ctx.fill();

    ctx.fillStyle = "rgba(255,255,255,0.90)";
    roundRect(x-6, y+38, 12, 26, 8); ctx.fill();
    roundRect(x+te.w-6, y+38, 12, 26, 8); ctx.fill();

    // face
    const faceR = 16;
    const faceCx = x + te.w/2;
    const faceCy = y + 18;
    const faceImg = getTeacherFace(te.who);

    ctx.save();
    ctx.beginPath();
    ctx.arc(faceCx, faceCy, faceR, 0, Math.PI*2);
    ctx.clip();

    const imgW = faceImg.width || 220;
    const imgH = faceImg.height || 220;
    const scale = Math.max((faceR*2)/imgW, (faceR*2)/imgH);
    const dw = imgW * scale;
    const dh = imgH * scale;
    ctx.drawImage(faceImg, faceCx - dw/2, faceCy - dh/2, dw, dh);
    ctx.restore();

    // head outline
    ctx.strokeStyle = "rgba(0,0,0,0.25)";
    ctx.lineWidth = 2;
    ctx.beginPath(); ctx.arc(faceCx, faceCy, faceR, 0, Math.PI*2); ctx.stroke();

    // NAME badge (very visible)
    const badgeW = te.w + 26;
    const badgeH = 22;
    const bx = x + te.w/2 - badgeW/2;
    const by = y - 26;

    ctx.fillStyle = "rgba(0,0,0,0.72)";
    roundRect(bx, by, badgeW, badgeH, 10); ctx.fill();

    ctx.strokeStyle = "rgba(255,255,255,0.9)";
    ctx.lineWidth = 2;
    roundRect(bx, by, badgeW, badgeH, 10); ctx.stroke();

    ctx.font = "900 14px system-ui";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.lineWidth = 4;
    ctx.strokeStyle = "rgba(0,0,0,0.95)";
    ctx.strokeText(te.who, bx + badgeW/2, by + badgeH/2);
    ctx.fillStyle = "rgba(255,255,255,0.98)";
    ctx.fillText(te.who, bx + badgeW/2, by + badgeH/2);
    ctx.textAlign = "left";
    ctx.textBaseline = "alphabetic";

    ctx.restore();
  }

  function drawExam(ex){
    ctx.save();
    ctx.globalAlpha = 0.95;
    ctx.fillStyle = "rgba(255,255,255,0.92)";
    roundRect(ex.x, ex.y, ex.w, ex.h, 10); ctx.fill();

    ctx.globalAlpha = 0.92;
    ctx.fillStyle = (ex.type==="FINAL") ? "rgba(200,40,70,1)" : "rgba(40,120,200,1)";
    ctx.font = "900 13px system-ui";
    ctx.textAlign = "center";
    ctx.fillText(ex.type, ex.x + ex.w/2, ex.y + ex.h/2 + 5);
    ctx.textAlign = "left";
    ctx.restore();
  }

  function overlay(title, subtitle){
    ctx.save();
    ctx.globalAlpha = 0.35;
    ctx.fillStyle = "white";
    ctx.fillRect(0,0,W,H);

    ctx.globalAlpha = 1;
    ctx.textAlign = "center";
    ctx.fillStyle = "rgba(25,30,40,0.95)";
    ctx.font = "900 48px system-ui";
    ctx.fillText(title, W/2, H/2 - 12);
    ctx.fillStyle = "rgba(25,30,40,0.78)";
    ctx.font = "16px system-ui";
    ctx.fillText(subtitle, W/2, H/2 + 22);

    ctx.restore();
    ctx.textAlign = "left";
  }

  function roundRect(x,y,w,h,r){
    const rr = Math.min(r, w/2, h/2);
    ctx.beginPath();
    ctx.moveTo(x+rr, y);
    ctx.arcTo(x+w, y, x+w, y+h, rr);
    ctx.arcTo(x+w, y+h, x, y+h, rr);
    ctx.arcTo(x, y+h, x, y, rr);
    ctx.arcTo(x, y, x+w, y, rr);
    ctx.closePath();
  }

  // Main loop
  let last = performance.now();
  function loop(now){
    const dt = clamp((now-last)/1000, 0, 0.033);
    last = now;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  // Load teacher photos once, then start
  loadTeacherPhotos().then(() => {
    restart();
    requestAnimationFrame(loop);
  });

})();
</script>
</body>
</html>
